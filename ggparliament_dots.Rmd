---
title: "geom_parliament_dots"
author: "Zoe Meers"
date: "16/05/2018"
output: html_document
---
```{r setup, echo=FALSE, warning=FALSE, message = FALSE, comment = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message = FALSE, comment = FALSE)
library(tidyverse)
library(pscl)
```


```{r}
geom_parliament_dots <- function(totalseats=NULL, parlrows=NULL, seatspp=NULL, party_names=NULL, type=c("u-shape", "hemicycle")) {
  if (type == "u-shape") {
    seats <- function(N, M, r0=5.5) {
      radii <- seq(r0, 7, len = M)

      counts <- numeric(M)
      pts <- do.call(
        rbind,
        lapply(1:M, function(i) {
          counts[i] <<- round(N * radii[i] / sum(radii[i:M]))
          theta <- seq(0, pi, len = counts[i])
          N <<- N - counts[i]
          data.frame(
            x = radii[i] * cos(theta), y = radii[i] * sin(theta), r = i,
            theta = theta
          )
        })
      )
      pts <- pts[order(-pts$theta, -pts$r), ]
      pts
    }


    election <- function(seats, counts) {
      stopifnot(sum(counts) == nrow(seats))
      seats$party <- rep(1:length(counts), counts)
      seats
    }
    layout <- seats(totalseats, parlrows)
    result <- election(layout, seatspp)

    geom_point(data = result, aes(x, y, colour = as.character(party)))
  }
  else{
    seats <- function(N, M, r0=3) {
      radii <- seq(r0, 5, len = M)

      counts <- numeric(M)
      pts <- do.call(
        rbind,
        lapply(1:M, function(i) {
          counts[i] <<- round(N * radii[i] / sum(radii[i:M]))
          theta <- seq(0, pi, len = counts[i])
          N <<- N - counts[i]
          data.frame(
            x = radii[i] * cos(theta), y = radii[i] * sin(theta), r = i,
            theta = theta
          )
        })
      )
      pts <- pts[order(-pts$theta, -pts$r), ]
      pts
    }


    election <- function(seats, counts) {
      stopifnot(sum(counts) == nrow(seats))
      seats$party <- rep(1:length(counts), counts)
      seats
    }
    layout <- seats(totalseats, parlrows)
    result <- election(layout, seatspp)
    

    geom_point(data = result, aes(x, y, colour = as.character(party)))
  }
}
```



```{r}
library(ggparliament)
data("US_congress")
US_congress1 <- US_congress %>%
  filter(start_year=="2017" & chamber=="lower")
congress <- ggplot() + geom_parliament_dots(type='hemicycle', totalseats=sum(US_congress1$seats), parlrows=10, seatspp=US_congress1$seats) + theme_void() + labs(colour="Party", title="United States Congress") + scale_colour_manual(values=c("blue", "red"), labels=c("D", "R"))
US_senate <- US_congress %>%
  filter(start_year=="2017" & chamber=="upper")
senate <- ggplot() + geom_parliament_dots(type='hemicycle', totalseats=sum(US_senate$seats), parlrows=3, seatspp=US_senate$seats) + theme_void() + labs(colour="Party", title="United States Senate") + scale_colour_manual(values=c("blue", "red", "gray"), labels=c("D", "R", "I"))
senate
congress
```

```{r}
# load data
AustralianElections <- pscl::AustralianElections
# filter to 2016, slice percent, total seats
AustralianElections <- AustralianElections %>%
  filter(date == "2016-07-02") %>%
  gather() %>%
  slice(-c(1:3, 8:19))

# reorder rows into parliament layout (i.e. independents in the middle of the circle btwn the two major parties)
AustralianElections <- AustralianElections[c(1, 4, 3, 2), ]
AustralianElections$key <- factor(AustralianElections$key)
# clean labels
AustralianElections$key <- gsub("Seats", "", AustralianElections$key)
Aus <- AustralianElections
saveRDS(Aus, "aus_2016.rds")
readRDS("aus_2016.rds")

```


```{r}
au <- readRDS("aus_2016.rds")
parliament_data <- function(data= NA,seats=NA, party = NA, type=c('hemicycle','u-shape')){
  if (type=='u-shape'){
    data$Share <- seats/sum(seats)
    data$ymax <- cumsum(data$Share)
    data$ymin <- c(0, head(data$ymax, n=-1))
    return(data)
  }
}

new_au_data <- parliament_data(data=au, seats=au$value, type='u-shape')

ggplot() + geom_parliament_dots(type='u-shape', totalseats=sum(new_au_data$value), parlrows = 4, seatspp=new_au_data$value) + theme_void() +  labs(colour="Party", title="U-shaped parliament: Australia") + scale_colour_party(palette = "AUS")




```


```{r}
#load data
VoteGermany2013 <- data.frame(Party=c( "CDU/CSU", "SPD", "LINKE","GRUENE"),
                          Result=c(311,193,64,63))
```

```{r}
## Functions to create political party colour palettes for ggparliament
## Zoe Meers

#' all colours
party_cols <- c(
    `light blue` = "#009de3",
    `dark blue` = "#1c396e",
    `red` = "#ed1b35",
    `light grey` = "#cccccc",
    `dark grey` = "#8c8c8c",
    `black` = "#000000",
    `green` = "#009900",
    `yellow` = "#FFFF00",
    `maroon`= "#800000",
    `navy`= "#000080",
    `purple`= "#800080",
    `orange`= "#FF5733",
    `blue` = "#0000FF"
)

#' Function to extract party colours as hex codes
#'
#' @param ... Character names of party_colours
#' @author
#' Zoe Meers
party_colours <- function(...) {
    cols <- c(...)
    
    if (is.null(cols)) {
        return(party_cols)
    }
    
    party_cols[cols]
}

#' Political party palettes
#' @description
#' This list creates palette types.
#' @author
#' Zoe Meers
#'
party_pal <- list(
    `GER` = party_colours("red", "dark grey", "green", "blue"),
    `AUS` = party_colours("red", "dark grey", "green", "blue"),
    `USA` = party_colours("red", "green", "blue"),
    `FRA` = party_colours("red", "maroon", "yellow", "orange", "light blue", "dark blue", "dark grey")
)

#' Return function to interpolate a party colour palette
#'
#' @param palette Character name of palette in party_pal (i.e. main, blue, light, dark, grey, mixed)
#' @param reverse Boolean indicating whether the palette should be reversed
#' @param ... Additional arguments to pass to colorRampPalette()
#' @author
#' Zoe Meers
#'

party_palettes <- function(palette = "AUS", reverse = FALSE, ...) {
    pal <- party_pal[[palette]]
    
    if (reverse) pal <- rev(pal)
    
    colorRampPalette(pal, ...)
}

#' colour scale constructor for party colours
#'
#' @param palette Character name of palette in party_pal (i.e. main, blue, light, dark, grey, mixed)
#' @param discrete Boolean indicating whether colour aesthetic is discrete or not
#' @param reverse Boolean indicating whether the palette should be reversed
#' @param ... Additional arguments passed to discrete_scale() or
#'            scale_colour_gradientn(), used respectively when discrete is TRUE or FALSE
#' @examples
#' Colour by discrete variable using default palette
#' ggplot(iris, aes(Sepal.Width, Sepal.Length, colour = Species)) + geom_point(size = 4) + scale_colour_party()
#' Reverse colour using blue palette
#' ggplot(iris, aes(Sepal.Width, Sepal.Length, colour = Species)) + geom_point(size = 4) + scale_colour_party('blue', reverse=T)
#' Remember, you can change the transparency of the colour by adding alpha to the geom_...() call
#' ggplot(iris, aes(Sepal.Width, Sepal.Length, colour = Species)) + geom_point(size = 4, alpha=0.4) + scale_colour_party('blue', reverse=T)
#' @author
#' Zoe Meers

scale_colour_party <- function(palette = "AUS", discrete = TRUE, reverse = FALSE, ...) {
    pal <- party_palettes(palette = palette, reverse = reverse)
    
    if (discrete) {
        discrete_scale("colour", paste0("party_", palette), palette = pal, ...)
    } else {
        scale_colour_gradientn(colours = pal(256), ...)
    }
}

#' Fill scale constructor for party colours
#'
#' @param palette Character name of palette in party_pal (i.e. main, blue, light, dark, grey, mixed)
#' @param discrete Boolean indicating whether colour aesthetic is discrete or not
#' @param reverse Boolean indicating whether the palette should be reversed
#' @param ... Additional arguments passed to discrete_scale() or
#'            scale_fill_gradient(), used respectively when discrete is TRUE or FALSE
#' @examples
#' Fill by discrete variable with different palette + remove legend (guide)
#' ggplot(mpg, aes(manufacturer, fill = manufacturer)) + geom_bar() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + scale_fill_party(palette = "main", guide = "none")
#' Set colour transparency by calling alpha in the geom_...() command
#' ggplot(mpg, aes(manufacturer, fill = manufacturer)) + geom_bar(alpha=0.7) + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + scale_fill_party(palette = "main", guide = "none")
#' @author
#' Zoe Meers
scale_fill_party <- function(palette = "AUS", discrete = TRUE, reverse = FALSE, ...) {
    pal <- party_palettes(palette = palette, reverse = reverse)
    
    if (discrete) {
        discrete_scale("fill", paste0("party_", palette), palette = pal, ...)
    } else {
        scale_colour_gradientn(colours = pal(256), ...)
    }
}

```



```{r}
germany <- ggplot() + geom_parliament_dots(type='hemicycle', totalseats=sum(VoteGermany2013$Result), parlrows=10, seatspp=VoteGermany2013$Result) + theme_void() + labs(colour="Party", title="Hemicycle parliament: Germany") + scale_colour_party(palette="GER")
germany
```



```{r}
#plot data
australia_parliament <- ggplot() + geom_parliament_dots(type='u-shape', totalseats=sum(AustralianElections$value), parlrows = 4, seatspp=AustralianElections$value) + theme_void() +  labs(colour="Party", title="U-shaped parliament: Australia") + scale_colour_party(palette = "AUS")
australia_parliament
```

```{r}

```



